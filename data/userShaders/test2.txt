#version 430
layout( local_size_x = 8, local_size_y = 8, local_size_z = 8 ) in;
layout( binding = 0, rgba8 ) uniform image3D colorBlockFront;
layout( binding = 1, rgba8 ) uniform image3D colorBlockBack;
layout( binding = 2, r8ui ) uniform uimage3D maskBlockFront;
layout( binding = 3, r8ui ) uniform uimage3D maskBlockBack;
layout( binding = 4, rgba8ui ) uniform uimage3D blueNoise;

vec4 blue ( ivec2 offset ) {
	const ivec2 noiseLoc = ivec2( gl_GlobalInvocationID.xy + offset ) % imageSize( blueNoiseTexture );
	return vec4( imageLoad( blueNoiseTexture, noiseLoc ) ) / 255.0;
}

vec3 getLocation( vec3 jitter ) {
	const vec3 computeLoc = vec3( gl_GlobalInvocationID.xyz );
	const vec3 loc = computeLoc + jitter;
	const vec3 blockDim = vec3( imageSize( colorBlockFront ) );
	return ( loc - blockDim / 2.0 ) / ( blockDim / 2.0 );
}

// the intersection record
struct irec {
	bool draw = false;
	vec4 color = vec4( 0.0 );
	int mask = 0;
};

const float scalar = 4.0;
const float epsilon = 0.001;
irec isInside ( vec3 p ) { // check Documentation tab for details
	irec temp;
	p *= scalar;



	return temp;
}


void main () {
	vec4 previousColor = imageLoad( colorBlockBack, ivec3( gl_GlobalInvocationID.xyz ) );
	uint previousMask = imageLoad( maskBlockBack, ivec3( gl_GlobalInvocationID.xyz ) ).r;

	float hitcount = 0.0; // number of true hits
	float masktotal = 0.0; // accumulated mask total
	vec4 accumulatedColor = vec4( 0.0 );


/*
	irec temp;
	int hitcount = 0;
	for ( int i = 0; i < 32; i++ ) {
		vec3 pos = myloc + 0.618 * scalar * blue( ivec2( i * int( myloc.x ) ) ).xyz;
		if ( de( pos ) < EPSILON ) {
			temp.draw = true;
			temp.color.xyz += vec3( 1 );
			temp.color.a += 0.75;
			hitcount++;
		}
	}

	if ( hitcount > 0 )
		temp.color.rgba /= float( hitcount );
	return temp;
*/


	const int numSamples = 32;
	for ( int i = 0; i < numSamples; i++ ) {
		irec sample = isInside( getLocation( blue( ivec2( i ) ).xyz ) );
		if ( sample.draw ) {
			hitcount++;
			maskTotal += sample.mask;
			accumulatedColor += sample.color;
		}
	}

	// blend with the previous color, based on the number of samples inside vs outside

	imageStore( colorBlockFront, ivec3( gl_GlobalInvocationID.xyz ), i.draw ? mix( i.color, previousColor, previousMask / 255.0 ) : previousColor );
	imageStore( maskBlockFront, ivec3( gl_GlobalInvocationID.xyz ), uvec4( ( previousMask > i.mask ) ? previousMask : i.mask ) );
}
